import json
import os
import pandas as pd
import requests
from flask import jsonify
from sentry_sdk import capture_exception, capture_message
from sqlalchemy import text
from datetime import datetime
import numpy as np
import time
from backend.database_config import Session
import concurrent.futures
from dotenv import load_dotenv
from backend.new_h1 import finish_international
import markdown
from backend.tables import internships_table, removed_jobs_global_table
from backend.ai_generation import get_single_title_embedding, get_single_description_embedding
from elasticsearch import Elasticsearch

"""
jobs.py is a file containing all functions to make transactions to and from the jobs tables in the database.
It contains functions to search for jobs using the TheirStack API, add jobs to the database, get jobs from the database,
as well as update certain columns of jobs in the database such as location, industry, and international availability.
In addition to this, the logic for the main searching function is also in this file. Including parsing the resume
with our OpenAI API, and the main get_jobs() function that matches search terms and resumes to jobs in the database.

Any new functions or updates to functions referring to getting, adding, or updating jobs in the database should be 
done here.
"""

load_dotenv()

# Password for the 'elastic' user generated by Elasticsearch
ELASTIC_PASSWORD = os.getenv("ELASTIC_PASSWORD")

# Found in the 'Manage Deployment' page
CLOUD_ID = os.getenv("CLOUD_ID")

# Create the client instance
elasticsearch_client = Elasticsearch(
    cloud_id=CLOUD_ID,
    basic_auth=("elastic", ELASTIC_PASSWORD)
)


def search_jobs(revealed, not_ids):
    """
    Search for jobs using the TheirStack API. It searches the TheirStack API with specific criteria, including
    only searching for jobs where 'intern', 'internship', or 'co-op' is in the title, and the job is located in the US.
    It searches for jobs discovered within the past day, in order to get the most recent postings. This is the
    function that is called every hour to load jobs into our database.

    :param revealed: A boolean value indicating whether to search for companies that are revealed or not. Set to 'None'
    for regular searching.
    :param not_ids: A list of job ids to exclude from the search. This is used to prevent from including jobs that we
    have already loaded recently.
    :return: data - which is the list of jobs found.
    """
    try:
        url = "https://api.theirstack.com/v1/jobs/search"
        payload = {
            "order_by": [
                {
                    # Order by the most recent discovered jobs
                    "desc": True,
                    "field": "discovered_at"
                }
            ],
            "page": 0,
            "limit": 500,  # This is the maximum limit it allows us to set
            "include_total_results": True,
            "job_id_not": not_ids,  # Jobs we DON'T want to include in our search, because we have already discovered them
            "company_type": "direct_employer",  # Only search for direct employers - exclude recruiting companies
            "company_name_not": ["WayUp", "RippleMatch", "Lensa", "Jobs via Dice", 'Jobright.ai'],  # Exclude WayUp, RippleMatch, Lensa, and Jobs via Dice
            "job_title_or": ["intern", "internship", "co-op"],  # Only internships and co-ops
            "job_country_code_or": ["US"],  # Only job postins in the US
            "discovered_at_max_age_days": 1,  # 1 for real searching - only jobs discovered in the last day
            "posted_at_max_age_days": 20,  # 20 for real searching - only jobs posted in the last 20 days.
            # ^ The reason why this is 20 is because jobs can be discovered at a later date than when they are posted.
            "revealed_company_data": revealed  # None/True/False
        }
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {os.getenv('THEIRSTACK_API_KEY')}"
        }
        response = requests.post(url, json=payload, headers=headers)  # Request data from TheirStack API

        data = response.json()['data']  # The jobs returned

        if len(data) == 0:
            capture_message("WARNING: 0 jobs found in search_jobs()", level="warning")

        return data
    except Exception as e:
        capture_exception(e)
        return []


def add_jobs_to_db(jobs):
    """
    Add jobs to the database. This function creates a table in the database if it does not exist, and then adds the list
    of jobs to the jobs table in the database. It checks if the job already exists in the database before adding it, to
    prevent duplicates. It updates the location if needed, updates the industry if needed, and computes the
    international availability of the job.
    :param jobs: list of jobs (returned from the search_jobs function) to add to the database
    :return: None
    """
    session = Session
    try:
        # Create the internships table if it doesn't exist
        session.execute(text(f'''CREATE TABLE IF NOT EXISTS {internships_table}
                             (id INT,
                              title TEXT,
                              company TEXT,
                              company_logo TEXT,
                              location TEXT,
                              state_code TEXT,
                              latitude FLOAT,
                              longitude FLOAT,
                              remote BOOLEAN,
                              salary TEXT,
                              date_posted TEXT,
                              url TEXT,
                              final_url TEXT,
                              company_url TEXT,
                              description TEXT,
                              company_industry TEXT,
                              company_employee_count_range TEXT,
                              international_availability BOOLEAN,
                              grade_level TEXT                       
                              )'''))
        session.commit()

        for job in jobs:  # Iterate through the list of jobs given
            try:
                # Check if the job already exists
                existing_job = session.execute(text(f'''
                            SELECT id FROM {internships_table} 
                            WHERE id = :id
                        '''), {
                    'id': job['id']
                }).fetchall()
                session.commit()

                if len(existing_job) < 1:  # If the job is not already in the database
                    # Insert the job into the database
                    session.execute(text(f'''
                                        INSERT INTO {internships_table} (id, title, company, company_logo, location, state_code, latitude, longitude, remote, 
                                                            salary, date_posted, url,
                                                            final_url, company_url, description,
                                                            company_industry, company_employee_count_range,
                                                            international_availability, grade_level)
                                        VALUES (:id, :title, :company, :company_logo, :location, :state_code, :latitude, :longitude, :remote, 
                                                :salary, :date_posted, :url,
                                                :final_url, :company_url, :description,
                                                :company_industry, :company_employee_count_range,
                                                :international_availability, :grade_level)
                                                RETURNING id
                                            '''), {
                        'id': job['id'],
                        'title': job['job_title'] if 'job_title' in job else job['title'],
                        'company': job['company'],
                        'company_logo': job['company_object']['logo'] if 'company_object' in job else job['company_logo'],
                        'location': job['location'],
                        'state_code': job['state_code'],
                        'latitude': job['latitude'],
                        'longitude': job['longitude'],
                        'remote': job['remote'],
                        'salary': job['salary_string'] if 'salary_string' in job else job['salary'],
                        'date_posted': job['date_posted'],
                        'url': job['url'],
                        'final_url': job['final_url'] if 'final_url' in job else job['url'],
                        'company_url': job['company_object']['url'] if 'company_object' in job else job['company_url'],
                        'description': job['description'],
                        'company_industry': job['company_object']['industry'] if 'company_object' in job else job[
                            'company_industry'],
                        'company_employee_count_range': job['company_object'][
                            'employee_count_range'] if 'company_object' in job else job['company_employee_count_range'],
                        'international_availability': None,  # Set to none originally, will be updated later
                        'grade_level': None  # Set to none, not used yet
                    })
            except Exception as e:
                capture_exception(e)
                session.rollback()

        session.commit()
        session.remove()

        finish_location()  # Call the finish_location function to update the location of the jobs to make sure it is usable
        find_industry_category_and_update_db(industries)  # Update the industry of the job for use
        finish_international('h1_data.csv')  # Calculate the international availability of the job and set it in the database

    except Exception as e:
        capture_exception(e)
        session.remove()


def get_job_from_id(job_id):
    """
    Get a job from the database by its ID. This function retrieves a job from the database using its ID and returns
    the job details as a dictionary. If the job is not found, it returns None.
    :param job_id: integer representing the job id
    :return: dictionary containing the job details or None if not found
    """
    session = Session

    try:

        # Use parameterized query to select all columns except the description for all jobs with the given IDs
        query = text(f'SELECT id, title, company, company_logo, location, state_code, latitude, longitude, remote, salary,'
                     'date_posted, url, final_url, company_url, company_industry, company_employee_count_range,'
                     f'international_availability, grade_level FROM {internships_table} WHERE id = :job_id')
        job = session.execute(query, {'job_id': job_id}).fetchone()

        if job:
            job_dict = {
                'id': job[0],
                'title': job[1],
                'company': job[2],
                'company_logo': job[3],
                'location': job[4],
                'state_code': job[5],
                'latitude': job[6],
                'longitude': job[7],
                'remote': job[8],
                'salary': job[9],
                'date_posted': job[10],
                'url': job[11],
                'final_url': job[12],
                'company_url': job[13],
                'company_industry': job[14],
                'company_employee_count_range': job[15],
                'international_availability': job[16],
                'grade_level': job[17],
            }

            session.remove()
            return job_dict
        else:
            session.remove()
            return None  # Return None if no job with the given id is found

    except Exception as e:
        capture_exception(e)
        session.remove()
        return None

def get_raw_description(job_id):
    """
    Get a job from the database by its ID. This function retrieves a job from the database using its ID and returns
    the job details as a dictionary. If the job is not found, it returns None.
    :param job_id: integer representing the job id
    :return: dictionary containing the job details or None if not found
    """
    session = Session

    try:

        # Use parameterized query to select all columns except the description for all jobs with the given IDs
        query = text(f'SELECT description FROM {internships_table} WHERE id = :job_id')
        desc = session.execute(query, {'job_id': job_id}).fetchone()

        if desc:
            session.remove()
            return desc[0]
        else:
            session.remove()
            return None  # Return None if no job with the given id is found

    except Exception as e:
        capture_exception(e)
        session.remove()
        return None


def get_jobs_from_database():
    """
    Get all jobs from the database. This function retrieves all jobs (with all parameters) and returns them
    :return: List of job dictionaries
    """
    session = Session
    try:
        results = session.execute(text(f'SELECT * FROM {internships_table}')).fetchall()  # Select all jobs
        jobs = []
        for job in results:
            # Set the dictionary representing the job
            job = {
                'id': job[0],
                'title': job[1],
                'company': job[2],
                'company_logo': job[3],
                'location': job[4],
                'state_code': job[5],
                'latitude': job[6],
                'longitude': job[7],
                'remote': job[8],
                'salary': job[9],
                'date_posted': job[10],
                'url': job[11],
                'final_url': job[12],
                'company_url': job[13],
                'description': job[14],
                'company_industry': job[15],
                'company_employee_count_range': job[16],
                'international_availability': job[17],
                'grade_level': job[18],
            }
            jobs.append(job)
        session.remove()

        if len(jobs) == 0:
            capture_message('ERROR: 0 jobs found in database', level="error")
        return jobs

    except Exception as e:
        capture_exception(e)
        session.remove()
        return []


def get_jobs_database_length():
    """
    Get the number of jobs in the internships table.
    :return: integer representing the number of jobs in the database
    """
    session = Session
    try:
        result = session.execute(text(f'SELECT COUNT(*) FROM {internships_table}')).fetchall()  # Select the number of rows in internships table
        session.remove()
        if result[0][0] == 0:
            capture_message('ERROR: 0 jobs found in database', level="error")

        return result[0][0]

    except Exception as e:
        capture_exception(e)
        session.remove()
        return 0


def get_jobs_from_idlist(job_ids):
    """
    Get jobs from the database using a list of job IDs. This function retrieves jobs from the database where the job ids
    match the given list of job IDs. It returns a list of job dictionaries (NOT INCLUDING DESCRIPTIONS)
    :param job_ids: list of job ids (integers)
    :return: list of job dictionaries
    """
    if not job_ids:
        return []  # Return an empty list if no IDs are provided

    session = Session

    try:

        # Use parameterized query to select all columns except the description for all jobs with the given IDs
        query = text(f'SELECT id, title, company, company_logo, location, state_code, latitude, longitude, remote, salary,'
                     'date_posted, url, final_url, company_url, company_industry, company_employee_count_range,'
                     f'international_availability, grade_level FROM {internships_table} WHERE id IN :job_ids')
        result = session.execute(query, {'job_ids': tuple(job_ids)}).fetchall()

        jobs = []
        for job in result:
            job_dict = {
                'id': job[0],
                'title': job[1],
                'company': job[2],
                'company_logo': job[3],
                'location': job[4],
                'state_code': job[5],
                'latitude': job[6],
                'longitude': job[7],
                'remote': job[8],
                'salary': job[9],
                'date_posted': job[10],
                'url': job[11],
                'final_url': job[12],
                'company_url': job[13],
                'company_industry': job[14],
                'company_employee_count_range': job[15],
                'international_availability': job[16],
                'grade_level': job[17],
            }
            jobs.append(job_dict)

        session.remove()
        return jobs

    except Exception as e:
        capture_exception(e)
        return []


def finish_location():
    """
    This function updates the location of jobs in the database. This is necessary because the given location of the
    jobs returned by TheirStack API is not always in the correct format. This function makes sure if it is remote,
    then the location is 'Remote' and the state_code, latitude, and longitude are set to NULL. It also makes sure that
    if the location is not empty, then the state_code, latitude, and longitude are set to the correct values.
    :return: None
    """
    session = Session

    try:

        # Update rows where Location is 'Remote' so that the all the location columns are correct
        # state_code, latitude, and longitude are set to NULL because there is no location
        session.execute(
            text(f'''UPDATE {internships_table}
                        SET Remote = TRUE,
                            Location = 'Remote',
                            state_code = NULL,
                            latitude = NULL,
                            longitude = NULL
                        WHERE Location = 'Remote' OR Remote = TRUE''')
        )

        session.commit()

        BASE_DIR = os.path.dirname(__file__)

        cities_df = pd.read_csv(os.path.join(BASE_DIR, "uscities.csv"))  # Load cities data from CSV file

        # Fetch jobs where Remote is False and state_code is empty and location is not empty
        # This means that the job has a location, but the state_code is not set
        jobs_to_update = session.execute(
            text(f'''
                SELECT *
                FROM {internships_table}
                WHERE Remote = FALSE
                  AND location IS NOT NULL
                  AND (state_code IS NULL OR state_code = '' OR LENGTH(state_code) > 2)
            ''')
        ).fetchall()

        session.remove()

    except Exception as e:
        capture_exception(e)
        session.remove()
        jobs_to_update = []
        BASE_DIR = os.path.dirname(__file__)
        cities_df = pd.read_csv(os.path.join(BASE_DIR, "uscities.csv"))  # Load cities data from CSV file

    for job in jobs_to_update:
        try:
            job_id = job.id
            job_location = job.location

            # Find the matching city in cities_df
            matched_city = cities_df[cities_df['city_ascii'].str.lower() == job_location.lower()].head(1)

            if not matched_city.empty:  # If a matching city is found
                state_code = matched_city.iloc[0]['state_id']  # Get the state of the matched city
                latitude = float(matched_city.iloc[0]['lat'])  # Get the latitude of the matched city
                longitude = float(matched_city.iloc[0]['lng']) # Get the longitude of the matched city

                # Update the job in the database, setting the state_code, latitude, and longitude
                session.execute(
                    text(f'''UPDATE {internships_table}
                               SET state_code = :state_code,
                                   latitude = :latitude,
                                   longitude = :longitude
                               WHERE id = :id'''),
                    {'state_code': state_code, 'latitude': latitude, 'longitude': longitude, 'id': job_id}
                )

            session.commit()
        except Exception as e:
            capture_exception(e)
            session.rollback()

    # Fetch jobs where Remote is False, Location is not empty, state_code is not empty, but the lat or long are NULL
    # This means all  the location text is correct, but there is no coordinates to match it
    jobs_to_update = session.execute(
        text(f'''SELECT id, location, state_code
                    FROM {internships_table}
                    WHERE Remote = FALSE AND location IS NOT NULL AND location != ''
                    AND state_code IS NOT NULL AND state_code != '' AND (latitude IS NULL OR longitude IS NULL)''')
    ).fetchall()

    for job in jobs_to_update:
        try:
            job_id = job.id
            job_location = job.location
            job_state_code = job.state_code

            # Find the matching city and state in cities_df
            matched_city = cities_df[(cities_df['city_ascii'].str.lower() == job_location.lower()) &
                                     (cities_df['state_id'].str.upper() == job_state_code.upper())].head(1)

            if not matched_city.empty:  # If a matching city, state is found
                latitude = matched_city.iloc[0]['lat']  # Get the latitude of the matched city, state
                longitude = matched_city.iloc[0]['lng']  # Get the longitude of the matched city, state

                # Update the job in the database, setting the latitude and longitude
                session.execute(
                    text(f'''UPDATE {internships_table}
                                SET latitude = :latitude,
                                    longitude = :longitude
                                WHERE id = :id'''),
                    {'latitude': latitude, 'longitude': longitude, 'id': job_id}
                )

            session.commit()

        except Exception as e:
            capture_exception(e)
            session.rollback()

    session.remove()


def get_jobs(search_terms, skills, search_type, title_score_threshold=0.8, description_score_threshold=0.5, max_results=2500):
    """
    This is is main function that searches for matching jobs.
    :param search_type: the type of search
    :param search_terms: A list of terms to search for in the job titles.
    :param skills: A list of skills to be used for matching to job descriptions.
    :param title_score_threshold: Matching threshold for titles to be considered. Set to 0.8 by default.
    :param description_score_threshold: Matching threshold for descriptions to be considered. Set to 0.5 by default.
    :param max_results: Maximum number of results to return
    :return: A list of matching jobs,  and the time taken to find them. (List of dictionaries, float)
    """
    try:
        timings = {}  # Time dictionary to track the time taken for each step
        start_time_final = time.time()  # Track total time

        # Step 1: Generate embeddings for all search terms and resume

        start_time1 = time.time()

        with concurrent.futures.ThreadPoolExecutor() as executor:
            # Submit each title embedding as its own future
            title_futures = {
                # Get embedding for each search term
                term: executor.submit(get_single_title_embedding, term, search_type) for term in search_terms
            }

            # Submit resume embedding
            # Get embedding from the skills list (convert list to string)
            future_resume_embedding = executor.submit(
                get_single_description_embedding, ' '.join(skills), search_type
            )

            # Collect the title embeddings
            term_embeddings = {
                term: future.result() for term, future in title_futures.items()
            }

            # Get resume embedding
            resume_embedding = future_resume_embedding.result()

        # Post-processing title embeddings
        valid_embeddings = {term: emb for term, emb in term_embeddings.items() if emb is not None}
        if not valid_embeddings:
            capture_exception(Exception("ERROR: get_jobs() Part 1 - No valid title embeddings generated."))
            return 'Error', {}

        if resume_embedding is None:
            capture_exception(Exception("ERROR: get_jobs() Part 1 - No valid resume embeddings generated."))
            return 'Error', {}

        timings['Job 1: Generate Embeddings Time'] = round(time.time() - start_time1, 2)

        # Step 2: Perform k-NN search for each embedding
        try:
            start_time2 = time.time()
            all_results = []
            for term, query_vector in valid_embeddings.items():

                response = elasticsearch_client.search(
                    index="title-embeddings-internships",  # Elasticsearch index for job titles
                    knn={
                        "field": "title_embedding",  # Embedding field
                        "query_vector": query_vector,  # Embedding vector
                        "k": 2500,  # Retrieve up to 2500 matches per search term
                        "num_candidates": 10_000  # Number of candidates to consider
                    },
                    size=2500,  # Limit response size
                    _source=[
                        "job_id",  # Fields to include in the response
                        "title"
                    ],
                )

                # Extract and store results
                matches = response["hits"]["hits"]
                for match in matches:
                    score = match["_score"]
                    if score >= title_score_threshold:  # Only include results above the score threshold
                        # Add the job_id, title, match_score, and best_match_term (term the job title best matches) to the results
                        all_results.append({
                            "job_id": match["_source"].get("job_id", "N/A"),
                            "title": match["_source"].get("title", "N/A"),
                            "match_score": score,
                            "best_match_term": term
                        })

            # Step 2.1: Aggregate results and keep the best match per job
            best_matches = {}
            for result in all_results:
                job_id = result["job_id"]
                if job_id not in best_matches or result["match_score"] > best_matches[job_id]["title_match_score"]:
                    best_matches[job_id] = {
                        "job_rec": result["best_match_term"],
                        "title_match_score": result["match_score"]
                    }

            timings['Job 2: KNN Title Searching Time'] = round(time.time() - start_time2, 2)

        except Exception as e:
            capture_exception(e)
            capture_exception(Exception("ERROR: get_jobs() Part 2 - Error during title k-NN search."))
            return 'Error', {}

        # Step 3: Perform filtered k-NN search for resume embedding - only for jobs that were title matches
        try:
            start_time3 = time.time()

            title_matched_job_ids = list(best_matches.keys())

            response = elasticsearch_client.search(
                index="description-embeddings-internships",  # Elasticsearch index for job descriptions
                knn={
                    "field": "description_embedding",  # Embedding field
                    "query_vector": resume_embedding,  # Resume embedding vector
                    "k": len(title_matched_job_ids),  # Retrieve matches for the number of title matches it found
                    "num_candidates": len(title_matched_job_ids),  # Number of candidates to consider
                    "filter": {
                        "terms": {
                            "job_id": title_matched_job_ids  # Only consider jobs from the title matches
                        }
                    }
                },
                size=len(title_matched_job_ids)
            )

            # Build a dictionary of job_id: description match score (only if score >= threshold)
            description_results = {
                hit["_source"]["job_id"]: hit["_score"]
                for hit in response["hits"]["hits"]
                if "_source" in hit and "job_id" in hit["_source"] and hit["_score"] >= description_score_threshold
            }

            timings['Job 3: KNN Description Search Time'] = round(time.time() - start_time3, 2)

        except Exception as e:
            capture_exception(e)
            capture_exception(Exception("ERROR: get_jobs() Part 3 - Error during description k-NN search."))
            return 'Error', {}

        # Step 4: Combine ID's and get job details
        try:
            start_time4 = time.time()

            matched_jobs = get_jobs_from_idlist(best_matches.keys())  # Get the jobs from the database which are matches

            timings['Job 4: Combine IDs and get jobs'] = round(time.time() - start_time4, 2)

        except Exception as e:
            capture_exception(e)
            capture_exception(Exception("ERROR: get_jobs() Part 4 - Error retrieving jobs from database."))
            return 'Error', {}

        # Step 5: Final computation and sort
        try:
            start_time5 = time.time()

            final_jobs = []

            for job in matched_jobs:
                job_id = job["id"]

                title_score = best_matches.get(job_id, {}).get("title_match_score", 0)  # The search term to title match score
                description_score = description_results.get(job_id, 0)  # The resume to description match score

                final_score = (title_score * 10) + (description_score * 5)  # Final score with weights

                if final_score >= 9:
                    # If the final score is above 9, add the match score and job rec (title match term) to the job info
                    job["match_score"] = final_score
                    job["job_rec"] = best_matches.get(job_id, {}).get("job_rec", None)
                    final_jobs.append(job)

            # Sort final list
            sorted_jobs = sorted(final_jobs, key=lambda x: x["match_score"], reverse=True)[:max_results]

            timings['Job 5: Final Computation and Sort'] = round(time.time() - start_time5, 2)
            timings['Total Time'] = round(time.time() - start_time_final, 2)

        except Exception as e:
            capture_exception(e)
            capture_exception(Exception("ERROR: get_jobs() Part 5 - Error during final scoring and sorting."))
            return 'Error', {}

        if timings['Total Time'] > 20:
            capture_message("WARNING: get_jobs() took over 20 seconds to complete.", level="warning")

        # Return the sorted jobs and the total time taken to run the function
        return sorted_jobs, timings

    except Exception as e:
        capture_exception(e)
        return 'Error', {}


def filter_by_location(jobs, cities_df, location_city=None, location_state=None, mile_radius=50):
    """
    Filters a given jobs list by location based on a specified city, state, and mile radius

    :param jobs: Given list of jobs to filter
    :param cities_df: Cities dataframe to consider
    :param location_city: City entered (text)
    :param location_state: State entered (text)
    :param mile_radius: An integer representing the mile radius to filter by
    :return:
    """

    try:

        mile_radius = float(mile_radius)  # Ensure mile_radius is a float

        # If no location is specified, return all jobs
        if location_city is None or location_state is None:
            return sorted(jobs, key=lambda x: x.get('match_score', 0), reverse=True)

        # Find the matching city in cities_df
        matched_city = cities_df[
            (cities_df['city_ascii'].str.lower() == location_city.lower()) &
            (cities_df['state_id'].str.upper() == location_state.upper())
            ].head(1)

        if matched_city.empty:
            capture_message(f'WARNING: Matched city not found for {location_city}, {location_state}', level="warning")
            return []

        # Extract target latitude and longitude
        target_lat = matched_city.iloc[0]['lat']
        target_lon = matched_city.iloc[0]['lng']

        # Separate remote jobs (they should always be included)
        jobs_df = pd.DataFrame(jobs)
        remote_jobs = jobs_df[jobs_df['remote'] == True]

        # Drop rows with null latitude or longitude (non-remote jobs only)
        non_remote_jobs = jobs_df[jobs_df['remote'] != True]
        non_remote_jobs = non_remote_jobs.dropna(subset=['latitude', 'longitude'])

        # Perform bulk distance calculation for non-remote jobs
        non_remote_jobs['distance'] = haversine_bulk(
            non_remote_jobs['latitude'].values,
            non_remote_jobs['longitude'].values,
            target_lat,
            target_lon
        )

        # Filter non-remote jobs based on distance
        non_remote_jobs = non_remote_jobs[non_remote_jobs['distance'] <= mile_radius]

        # Combine remote jobs and filtered non-remote jobs
        final_jobs = pd.concat([remote_jobs, non_remote_jobs], ignore_index=True)
        final_jobs = final_jobs.replace({np.nan: None})

        # Sort jobs by match score
        filtered_jobs = final_jobs.to_dict('records')
        filtered_jobs = sorted(filtered_jobs, key=lambda x: x.get('match_score', 0), reverse=True)

        return filtered_jobs

    except Exception as e:
        capture_exception(e)
        return []


def remove_job_rec(jobs, job_rec):
    """
    Removes all jobs of a given job_rec (search term) from the list of jobs.
    :param jobs: List of dictionaries representing jobs
    :param job_rec: string representing which search title to remove
    :return:
    """
    try:
        jobs = [job for job in jobs if job['job_rec'] != job_rec]  # Jobs that do not match the job_rec

        jobs = sorted(jobs, key=lambda x: x.get('match_score', 0),
                      reverse=True)

        return jobs
    except Exception as e:
        capture_exception(e)
        return []


def haversine_bulk(lat1, lon1, lat2, lon2):
    """
    Vectorized Haversine distance calculation.
    """
    try:
        R = 3958.8  # Earth radius in miles

        # Convert latitude and longitude from degrees to radians
        lat1, lon1, lat2, lon2 = map(np.radians, [lat1, lon1, lat2, lon2])

        # Compute differences
        dlat = lat2 - lat1
        dlon = lon2 - lon1

        # Haversine formula
        a = np.sin(dlat / 2) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2) ** 2
        c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))

        # Distance in miles
        return R * c
    except Exception as e:
        capture_exception(e)



def delete_job_from_database(job_id):
    """
    Delete a job from the database using its ID
    :param job_id: integer of the id of the job to delete
    :return: None
    """
    session = Session
    try:
        # Delete the job with the specified id
        result = session.execute(
            text(f'DELETE FROM {internships_table} WHERE id = :id RETURNING id'),
            {'id': job_id}
        )

        # Commit the transaction
        session.commit()

    except Exception as e:
        session.rollback()
        capture_exception(e)
    finally:
        session.remove()


def sort_job_listings_by_date(job_listings):
    """
    Sorts the job listings by the date they were posted, in descending order.
    :param job_listings: list of job dictionaries to be sorted
    :return: sorted list of job dictionaries
    """
    date_sorted = sorted(job_listings, key=lambda x: datetime.strptime(x['date_posted'], '%Y-%m-%d'), reverse=True)
    return date_sorted

# Define the industries and their subcategories
industries = {
    'Accommodation Services': ['Food and Beverage Services', 'Bars, Taverns, and Nightclubs', 'Caterers',
                               'Mobile Food Services',
                               'Restaurants', 'Hospitality', 'Bed-and-Breakfasts, Hostels, Homestays',
                               'Hotels and Motels'],
    'Administrative and Support Services': ["Collection Agencies", "Events Services", "Facilities Services",
                                            "Janitorial Services",
                                            "Landscaping Services", "Fundraising",
                                            "Office Administration", "Security and Investigations",
                                            "Security Guards and Patrol Services",
                                            "Security Systems Services", "Staffing and Recruiting",
                                            "Executive Search Services",
                                            "Temporary Help Services", "Telephone Call Centers",
                                            "Translation and Localization", "Travel Arrangements"],
    'Book and Periodical Publishing': ['Book Publishing', 'Newspaper Publishing', 'Periodical Publishing'],
    'Broadcast Media Production and Distribution': ['Radio and Television Broadcasting'],
    'Construction': ['Building Construction', 'Nonresidential Building Construction',
                     'Residential Building Construction',
                     'Civil Engineering', 'Highway, Street, and Bridge Construction', 'Utility System Construction',
                     'Specialty Trade Contractors', 'Building Equipment Contractors', 'Building Finishing Contractors',
                     'Building Structure and Exterior Contractors'],
    'Consumer Services': ["Civic and Social Organizations", "Household Services", "Non-profit Organizations",
                          "Personal and Laundry Services", "Philanthropic Fundraising Services",
                          "Religious Institutions", "Repair and Maintenance",
                          "Industry Associations", "Political Organizations", "Professional Organizations",
                          "Laundry and Drycleaning Services",
                          "Personal Care Services", "Pet Services", "Commercial and Industrial Machinery Maintenance",
                          "Electronic and Precision Equipment Maintenance", "Footwear and Leather Goods Repair",
                          "Vehicle Repair and Maintenance"],
    'Education': ["Education", "E-Learning Providers", "Higher Education", "Primary and Secondary Education",
                  "Professional Training and Coaching", "Technical and Vocational Training",
                  "Cosmetology and Barber Schools", "Fine Arts Schools", "Flight Training", "Language Schools",
                  "Sports and Recreation Instruction"],
    'Entertainment Providers': ['Artists and Writers', 'Museums, Historical Sites, and Zoos', 'Historical Sites',
                                'Museums', 'Zoos and Botanical Gardens', 'Musicians',
                                'Performing Arts and Spectator Sports',
                                'Dance Companies', 'Performing Arts', 'Spectator Sports', 'Racetracks',
                                'Sports Teams and Clubs',
                                'Theater Companies', "Recreational Facilities", "Amusement Parks and Arcades",
                                "Gambling Facilities and Casinos", "Golf Courses and Country Clubs",
                                "Skiing Facilities",
                                "Wellness and Fitness Services"],
    'Farming, Ranching, Forestry': ["Farming", "Horticulture", "Forestry and Logging", "Ranching and Fisheries",
                                    "Fisheries", "Ranching"],
    'Financial Services': ['Credit Intermediation', 'Banking', 'International Trade and Development', 'Loan Brokers',
                           "Capital Markets", "Investment Advice", "Investment Banking", "Investment Management",
                           "Securities and Commodity Exchanges", "Venture Capital and Private Equity Principals"
                                                                 'Funds and Trusts',
                           'Insurance and Employee Benefit Funds', 'Pension Funds',
                           'Trusts and Estates', 'Insurance', 'Claims Adjusting, Actuarial Services',
                           'Insurance Agencies and Brokerages', 'Insurance Carriers'],
    'Government Administration': ["Government Administration", "Administration of Justice", "Fire Protection",
                                  "Law Enforcement", "Public Safety", "Economic Programs", "Transportation Programs",
                                  "Utilities Administration", "Environmental Quality Programs",
                                  "Air, Water, and Waste Program Management", "Conservation Programs",
                                  "Health and Human Services", "Education Administration Programs",
                                  "Public Assistance Programs", "Public Health", "Housing and Community Development",
                                  "Community Development and Urban Planning", "Housing Programs",
                                  "Military and International Affairs", "Armed Forces", "International Affairs",
                                  "Public Policy Offices", "Executive Offices", "Legislative Offices",
                                  "Space Research and Technology"],
    'Holding Companies': [],
    'Manufacturing': ['Manufacturing', 'Apparel Manufacturing', 'Fashion Accessories Manufacturing',
                      'Appliances, Electrical, and Electronics Manufacturing',
                      'Electric Lighting Equipment Manufacturing',
                      'Electrical Equipment Manufacturing', 'Fuel Cell Manufacturing',
                      'Household Appliance Manufacturing',
                      'Chemical Manufacturing', 'Agricultural Chemical Manufacturing',
                      'Chemical Raw Materials Manufacturing', 'Paint, Coating, and Adhesive Manufacturing',
                      'Personal Care Product Manufacturing', 'Pharmaceutical Manufacturing',
                      'Soap and Cleaning Product Manufacturing', 'Climate Technology Product Manufacturing',
                      'Computers and Electronics Manufacturing', 'Audio and Video Equipment Manufacturing',
                      'Communications Equipment Manufacturing', 'Computer Hardware Manufacturing',
                      'Accessible Hardware Manufacturing', 'Magnetic and Optical Media Manufacturing',
                      'Measuring and Control Instrument Manufacturing', 'Semiconductor Manufacturing',
                      'Renewable Energy Semiconductor Manufacturing', 'Fabricated Metal Products',
                      'Architectural and Structural Metal Manufacturing',
                      'Boilers, Tanks, and Shipping Container Manufacturing',
                      'Construction Hardware Manufacturing', 'Cutlery and Handtool Manufacturing',
                      'Metal Treatments', 'Metal Valve, Ball, and Roller Manufacturing',
                      'Spring and Wire Product Manufacturing', 'Turned Products and Fastener Manufacturing',
                      'Food and Beverage Manufacturing', 'Animal Feed Manufacturing', 'Baked Goods Manufacturing',
                      'Beverage Manufacturing', 'Dairy Product Manufacturing',
                      'Fruit and Vegetable Preserves Manufacturing', 'Meat Products Manufacturing',
                      'Seafood Product Manufacturing', 'Sugar and Confectionery Product Manufacturing',
                      'Furniture and Home Furnishings Manufacturing',
                      'Household and Institutional Furniture Manufacturing',
                      'Mattress and Blinds Manufacturing', 'Office Furniture and Fixtures Manufacturing',
                      'Glass, Ceramics and Concrete Manufacturing', 'Abrasives and Nonmetallic Minerals Manufacturing',
                      'Clay and Refractory Products Manufacturing', 'Glass Product Manufacturing',
                      'Lime and Gypsum Products Manufacturing', 'Leather Product Manufacturing',
                      'Footwear Manufacturing', 'Machinery Manufacturing',
                      'Agriculture, Construction, Mining Machinery Manufacturing', 'Automation Machinery Manufacturing',
                      'Robot Manufacturing', 'Commercial and Service Industry Machinery Manufacturing',
                      'Engines and Power Transmission Equipment Manufacturing',
                      'Renewable Energy Equipment Manufacturing',
                      'HVAC and Refrigeration Equipment Manufacturing', 'Industrial Machinery Manufacturing',
                      'Metalworking Machinery Manufacturing', 'Medical Equipment Manufacturing',
                      'Paper and Forest Product Manufacturing', 'Plastics and Rubber Product Manufacturing',
                      'Packaging and Containers Manufacturing', 'Plastics Manufacturing',
                      'Rubber Products Manufacturing',
                      'Primary Metal Manufacturing', 'Printing Services', 'Sporting Goods Manufacturing',
                      'Textile Manufacturing', 'Tobacco Manufacturing', 'Transportation Equipment Manufacturing',
                      'Aviation and Aerospace Component Manufacturing', 'Defense and Space Manufacturing',
                      'Motor Vehicle Manufacturing', 'Motor Vehicle Parts Manufacturing',
                      'Railroad Equipment Manufacturing', 'Alternative Fuel Vehicle Manufacturing',
                      'Shipbuilding', 'Wood Product Manufacturing', 'Hospitals and Health Care',
                      'Community Services', 'Services for the Elderly and Disabled',
                      'Hospitals', 'Individual and Family Services', 'Child Day Care Services',
                      'Emergency and Relief Services', 'Vocational Rehabilitation Services',
                      'Medical Practices', 'Alternative Medicine', 'Ambulance Services',
                      'Chiropractors', 'Dentists', 'Home Health Care Services',
                      'Medical and Diagnostic Laboratories', 'Mental Health Care',
                      'Optometrists', 'Outpatient Care Centers',
                      'Physical, Occupational and Speech Therapists', 'Physicians',
                      'Nursing Homes and Residential Care Facilities'],
    'Movies, Videos and Sound': ['Movies, Videos and Sound', 'Animation and Post-production', 'Media Production',
                                 'Movies and Sound Recording', 'Sound Recording', 'Sheet Music Publishing'],
    'Oil, Gas, and Mining': ['Oil, Gas, and Mining', 'Mining', 'Metal Ore Mining', 'Nonmetallic Mineral Mining',
                             'Oil and Gas', 'Oil Extraction'],
    'Professional Services': ['Professional Services',
                              'Accounting', 'Advertising Services', 'Government Relations Services', 'Market Research',
                              'Public Relations and Communications Services', 'Architecture and Planning',
                              'Accessible Architecture and Design', 'Business Consulting and Services',
                              'Environmental Services', 'Human Resources Services', 'Marketing Services',
                              'Operations Consulting', 'Outsourcing and Offshoring Consulting',
                              'Strategic Management Services', 'Design Services', 'Graphic Design',
                              'Interior Design', 'Regenerative Design', 'Engineering Services', 'Robotics Engineering',
                              'Surveying and Mapping Services', 'IT Services and IT Consulting',
                              'Computer and Network Security', 'Digital Accessibility Services',
                              'IT System Custom Software Development',
                              'IT System Data Services', 'IT System Design Services',
                              'IT System Installation and Disposal',
                              'IT System Operations and Maintenance', 'IT System Testing and Evaluation',
                              'IT System Training and Support', 'Legal Services', 'Alternative Dispute Resolution',
                              'Law Practice', 'Photography', 'Research Services', 'Biotechnology Research',
                              'Nanotechnology Research', 'Think Tanks', 'Services for Renewable Energy',
                              'Veterinary Services'],
    'Real Estate and Equipment Rental Services': ['Real Estate and Equipment Rental Services',
                                                  'Equipment Rental Services',
                                                  'Commercial and Industrial Equipment Rental',
                                                  'Consumer Goods Rental',
                                                  'Real Estate',
                                                  'Leasing Non-residential Real Estate',
                                                  'Leasing Residential Real Estate',
                                                  'Real Estate Agents and Brokers'],
    'Retail': ['Retail',
               'Food and Beverage Retail', 'Retail Groceries', 'Online and Mail Order Retail',
               'Retail Apparel and Fashion', 'Retail Appliances, Electrical, and Electronic Equipment',
               'Retail Art Dealers', 'Retail Art Supplies', 'Retail Books and Printed News',
               'Retail Building Materials and Garden Equipment', 'Retail Florists',
               'Retail Furniture and Home Furnishings', 'Retail Gasoline',
               'Retail Health and Personal Care Products', 'Retail Pharmacies',
               'Retail Luxury Goods and Jewelry', 'Retail Motor Vehicles', 'Retail Musical Instruments',
               'Retail Office Equipment', 'Retail Office Supplies and Gifts',
               'Retail Recyclable Materials & Used Merchandise'],
    'Technology, Information and Media': ['Technology, Information and Media',
                                          'Media & Telecommunications', 'Technology, Information and Internet',
                                          'Data Infrastructure and Analytics', 'Blockchain Services',
                                          'Business Intelligence Platforms', 'Climate Data and Analytics',
                                          'Information Services',
                                          'Internet Publishing', 'Blogs', 'Business Content',
                                          'Online Audio and Video Media',
                                          'Internet News', 'Libraries', 'Internet Marketplace Platforms',
                                          'Social Networking Platforms', 'Software Development', 'Computer Games',
                                          'Mobile Gaming Apps', 'Computer Networking Products',
                                          'Data Security Software Products',
                                          'Desktop Computing Software Products', 'Embedded Software Products',
                                          'Mobile Computing Software Products'],
    'Telecommunications': ['Telecommunications', 'Satellite Telecommunications', 'Telecommunications Carriers',
                           'Wireless Services'],
    'Transportation, Logistics, Supply Chain and Storage': ['Transportation, Logistics, Supply Chain and Storage',
                                                            'Airlines and Aviation',
                                                            'Freight and Package Transportation',
                                                            'Ground Passenger Transportation',
                                                            'Interurban and Rural Bus Services',
                                                            'School and Employee Bus Services',
                                                            'Shuttles and Special Needs Transportation Services',
                                                            'Sightseeing Transportation', 'Taxi and Limousine Services',
                                                            'Urban Transit Services', 'Maritime Transportation',
                                                            'Pipeline Transportation', 'Postal Services',
                                                            'Rail Transportation', 'Truck Transportation',
                                                            'Warehousing and Storage'],
    'Utilities': ['Utilities',
                  'Electric Power Generation', 'Fossil Fuel Electric Power Generation',
                  'Nuclear Electric Power Generation',
                  'Renewable Energy Power Generation', 'Biomass Electric Power Generation',
                  'Geothermal Electric Power Generation', 'Solar Electric Power Generation',
                  'Wind Electric Power Generation', 'Electric Power Transmission, Control, and Distribution',
                  'Natural Gas Distribution', 'Water, Waste, Steam, and Air Conditioning Services',
                  'Steam and Air-Conditioning Supply', 'Waste Collection', 'Waste Treatment and Disposal',
                  'Water Supply and Irrigation Systems'],
    'Wholesale': ['Wholesale',
                  'Wholesale Alcoholic Beverages', 'Wholesale Apparel and Sewing Supplies',
                  'Wholesale Appliances, Electrical, and Electronics', 'Wholesale Building Materials',
                  'Wholesale Chemical and Allied Products', 'Wholesale Computer Equipment',
                  'Wholesale Drugs and Sundries',
                  'Wholesale Food and Beverage', 'Wholesale Footwear', 'Wholesale Furniture and Home Furnishings',
                  'Wholesale Hardware, Plumbing, Heating Equipment', 'Wholesale Import and Export',
                  'Wholesale Luxury Goods and Jewelry', 'Wholesale Machinery', 'Wholesale Metals and Minerals',
                  'Wholesale Motor Vehicles and Parts', 'Wholesale Paper Products',
                  'Wholesale Petroleum and Petroleum Products', 'Wholesale Photography Equipment and Supplies',
                  'Wholesale Raw Farm Products', 'Wholesale Recyclable Materials']}


def find_industry_category_and_update_db(industries_dict):
    """
    This function updates the company_industry column in the internships table based on the provided industries_dict.
    :param industries_dict: the dictionary containing the industries and subcategories
    :return: None
    """

    session = Session
    try:
        # Generate the condition to exclude keys from industries_dict
        excluded_keys = ', '.join(f"'{key}'" for key in industries_dict.keys())

        # Fetch jobs where company_industry is not in the keys of industries_dict
        query = f'''
        SELECT id, company_industry 
        FROM {internships_table} 
        WHERE company_industry NOT IN ({excluded_keys})
        '''
        jobs = session.execute(text(query)).fetchall()

        for job in jobs:
            try:
                job_id = job.id
                company_industry = job.company_industry

                # Search through the values (lists) in the dictionary
                new_industry = None
                for category, sub_industries in industries_dict.items():
                    if company_industry in sub_industries:  # If the job industry matches a sub-industry
                        new_industry = category  # Make the job industry the main category of the sub-industry
                        break

                # If a match is found, update the job's company_industry in the database
                if new_industry:
                    session.execute(
                        text(f'UPDATE {internships_table} SET company_industry = :new_industry WHERE id = :job_id'),
                        {'new_industry': new_industry, 'job_id': job_id}
                    )

                # Commit the transaction
                session.commit()

            except Exception as e:
                session.rollback()
                capture_exception(e)

    except Exception as e:
        session.rollback()
        capture_exception(e)
    finally:
        session.remove()


def add_removed_job_global(job):
    """
    Adds or updates a row in removed_jobs_global based on the job's ID.

    :param job: Dictionary with keys: id, reason, title, company, final_url, date_posted, time_added
    """
    session = Session

    try:
        # Check if the job already exists
        existing = session.execute(
            text(f"SELECT id, reasons, count FROM {removed_jobs_global_table} WHERE id = :id"),
            {"id": job['id']}
        ).fetchone()

        reason = job['reason']

        if existing:
            # Parse and update the reasons JSON
            existing_reasons = existing[1] or {}
            if reason in existing_reasons:
                existing_reasons[reason] += 1  # Increment the count for the existing reason
            else:
                existing_reasons[reason] = 1  # Add new reason with count 1

            # Update the row
            session.execute(
                text(f"""
                    UPDATE {removed_jobs_global_table}
                    SET count = :new_count,
                        reasons = :new_reasons
                    WHERE id = :id
                """),
                {
                    "id": job['id'],
                    "new_count": existing[2] + 1,  # Increment the count
                    "new_reasons": json.dumps(existing_reasons)
                }
            )

        else:
            # Insert new row
            session.execute(
                text(f"""
                    INSERT INTO {removed_jobs_global_table}
                    (id, count, reasons, title, company, final_url, date_posted, first_addition)
                    VALUES
                    (:id, :count, :reasons, :title, :company, :final_url, :date_posted, :first_addition)
                """),
                {
                    "id": job['id'],
                    "count": 1,
                    "reasons": json.dumps({reason: 1}),
                    "title": job['title'],
                    "company": job['company'],
                    "final_url": job['final_url'],
                    "date_posted": job['date_posted'],
                    "first_addition": datetime.fromisoformat(job['time_added'])
                }
            )

        session.commit()
    except Exception as e:
        session.rollback()
        capture_exception(e)
    finally:
        session.close()


def get_job_description(job_id):
    """
        Fetches the job description from the database and returns it in HTML format.

        Parameters:
        job_id (int): The unique identifier of the job.

        Returns:
        JSON response with the following keys:
        - 'status': 'success' if the description is found, 'fail' if not found, or 'error' if an error occurred.
        - 'html': The job description in HTML format if found, or an error message if not found or an error occurred.
    """
    this_session = Session
    try:
        # Get the job description from the database that matched the given id
        result = this_session.execute(text(f"SELECT description FROM {internships_table} WHERE id = :job_id"), {"job_id": job_id})
        row = result.fetchone()

        if row and row[0]:
            description = row[0]

            # Preprocess for markdown formatting
            html_description = markdown.markdown(description, extensions=['extra', 'sane_lists'])

            return jsonify({
                "status": "success",
                "html": html_description
            })
        else:
            return jsonify({
                "status": "fail",
                "html": "<p>Description not found.</p>"
            }), 404
    except Exception as e:
        print(f"Error fetching description: {e}")
        return jsonify({
            "status": "error",
            "html": "<p>Something went wrong while fetching the description.</p>"
        }), 500
    finally:
        this_session.commit()
        this_session.remove()



if __name__ == "__main__":
    print(get_jobs_database_length())
    # delete_job_from_database(540967951)
